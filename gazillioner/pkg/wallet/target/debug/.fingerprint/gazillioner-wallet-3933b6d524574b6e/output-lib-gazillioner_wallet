{"$message_type":"diagnostic","message":"unused import: `ChildNumber`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/hd.rs","byte_start":231,"byte_end":242,"line_start":9,"line_end":9,"column_start":5,"column_end":16,"is_primary":true,"text":[{"text":"    ChildNumber,","highlight_start":5,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/hd.rs","byte_start":225,"byte_end":242,"line_start":8,"line_end":9,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    Xpriv, Xpub,","highlight_start":16,"highlight_end":17},{"text":"    ChildNumber,","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `ChildNumber`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/hd.rs:9:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     ChildNumber,\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused import: `Zeroize`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/hd.rs","byte_start":337,"byte_end":344,"line_start":13,"line_end":13,"column_start":15,"column_end":22,"is_primary":true,"text":[{"text":"use zeroize::{Zeroize, ZeroizeOnDrop};","highlight_start":15,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/hd.rs","byte_start":337,"byte_end":346,"line_start":13,"line_end":13,"column_start":15,"column_end":24,"is_primary":true,"text":[{"text":"use zeroize::{Zeroize, ZeroizeOnDrop};","highlight_start":15,"highlight_end":24}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/hd.rs","byte_start":336,"byte_end":337,"line_start":13,"line_end":13,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"use zeroize::{Zeroize, ZeroizeOnDrop};","highlight_start":14,"highlight_end":15}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/hd.rs","byte_start":359,"byte_end":360,"line_start":13,"line_end":13,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"use zeroize::{Zeroize, ZeroizeOnDrop};","highlight_start":37,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `Zeroize`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hd.rs:13:15\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use zeroize::{Zeroize, ZeroizeOnDrop};\n   \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `PublicKey as BtcPublicKey`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/btc.rs","byte_start":215,"byte_end":240,"line_start":7,"line_end":7,"column_start":37,"column_end":62,"is_primary":true,"text":[{"text":"    Address, Network as BtcNetwork, PublicKey as BtcPublicKey,","highlight_start":37,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/btc.rs","byte_start":213,"byte_end":240,"line_start":7,"line_end":7,"column_start":35,"column_end":62,"is_primary":true,"text":[{"text":"    Address, Network as BtcNetwork, PublicKey as BtcPublicKey,","highlight_start":35,"highlight_end":62}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `PublicKey as BtcPublicKey`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/btc.rs:7:37\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Address, Network as BtcNetwork, PublicKey as BtcPublicKey,\n  \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `SecretKey`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/btc.rs","byte_start":528,"byte_end":537,"line_start":16,"line_end":16,"column_start":37,"column_end":46,"is_primary":true,"text":[{"text":"use secp256k1::{Secp256k1, Message, SecretKey};","highlight_start":37,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/btc.rs","byte_start":526,"byte_end":537,"line_start":16,"line_end":16,"column_start":35,"column_end":46,"is_primary":true,"text":[{"text":"use secp256k1::{Secp256k1, Message, SecretKey};","highlight_start":35,"highlight_end":46}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `SecretKey`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/btc.rs:16:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use secp256k1::{Secp256k1, Message, SecretKey};\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `SecretKey`, `ecdsa::RecoverableSignature`, and `ecdsa::RecoveryId`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/eth.rs","byte_start":279,"byte_end":288,"line_start":9,"line_end":9,"column_start":37,"column_end":46,"is_primary":true,"text":[{"text":"use secp256k1::{Secp256k1, Message, SecretKey, ecdsa::RecoverableSignature, ecdsa::RecoveryId};","highlight_start":37,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/eth.rs","byte_start":290,"byte_end":317,"line_start":9,"line_end":9,"column_start":48,"column_end":75,"is_primary":true,"text":[{"text":"use secp256k1::{Secp256k1, Message, SecretKey, ecdsa::RecoverableSignature, ecdsa::RecoveryId};","highlight_start":48,"highlight_end":75}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/eth.rs","byte_start":319,"byte_end":336,"line_start":9,"line_end":9,"column_start":77,"column_end":94,"is_primary":true,"text":[{"text":"use secp256k1::{Secp256k1, Message, SecretKey, ecdsa::RecoverableSignature, ecdsa::RecoveryId};","highlight_start":77,"highlight_end":94}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src/eth.rs","byte_start":277,"byte_end":336,"line_start":9,"line_end":9,"column_start":35,"column_end":94,"is_primary":true,"text":[{"text":"use secp256k1::{Secp256k1, Message, SecretKey, ecdsa::RecoverableSignature, ecdsa::RecoveryId};","highlight_start":35,"highlight_end":94}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused imports: `SecretKey`, `ecdsa::RecoverableSignature`, and `ecdsa::RecoveryId`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/eth.rs:9:37\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use secp256k1::{Secp256k1, Message, SecretKey, ecdsa::RecoverableSignature, ecdsa::RecoveryId};\n  \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `SignedEthereumTransaction`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/evm.rs","byte_start":436,"byte_end":461,"line_start":14,"line_end":14,"column_start":72,"column_end":97,"is_primary":true,"text":[{"text":"use crate::eth::{EthereumWallet, EthereumAddress, EthereumTransaction, SignedEthereumTransaction};","highlight_start":72,"highlight_end":97}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/evm.rs","byte_start":434,"byte_end":461,"line_start":14,"line_end":14,"column_start":70,"column_end":97,"is_primary":true,"text":[{"text":"use crate::eth::{EthereumWallet, EthereumAddress, EthereumTransaction, SignedEthereumTransaction};","highlight_start":70,"highlight_end":97}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `SignedEthereumTransaction`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:14:72\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::eth::{EthereumWallet, EthereumAddress, EthereumTransaction, SignedEthereumTransaction};\n   \u001b[1m\u001b[94m|\u001b[0m                                                                        \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `WalletError`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/evm.rs","byte_start":518,"byte_end":529,"line_start":16,"line_end":16,"column_start":20,"column_end":31,"is_primary":true,"text":[{"text":"use crate::error::{WalletError, Result};","highlight_start":20,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/evm.rs","byte_start":518,"byte_end":531,"line_start":16,"line_end":16,"column_start":20,"column_end":33,"is_primary":true,"text":[{"text":"use crate::error::{WalletError, Result};","highlight_start":20,"highlight_end":33}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/evm.rs","byte_start":517,"byte_end":518,"line_start":16,"line_end":16,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"use crate::error::{WalletError, Result};","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/evm.rs","byte_start":537,"byte_end":538,"line_start":16,"line_end":16,"column_start":39,"column_end":40,"is_primary":true,"text":[{"text":"use crate::error::{WalletError, Result};","highlight_start":39,"highlight_end":40}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `WalletError`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:16:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::error::{WalletError, Result};\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `DerivationPath`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/ffi.rs","byte_start":297,"byte_end":311,"line_start":13,"line_end":13,"column_start":37,"column_end":51,"is_primary":true,"text":[{"text":"use crate::hd::{ExtendedPrivateKey, DerivationPath};","highlight_start":37,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/ffi.rs","byte_start":295,"byte_end":311,"line_start":13,"line_end":13,"column_start":35,"column_end":51,"is_primary":true,"text":[{"text":"use crate::hd::{ExtendedPrivateKey, DerivationPath};","highlight_start":35,"highlight_end":51}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/ffi.rs","byte_start":276,"byte_end":277,"line_start":13,"line_end":13,"column_start":16,"column_end":17,"is_primary":true,"text":[{"text":"use crate::hd::{ExtendedPrivateKey, DerivationPath};","highlight_start":16,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/ffi.rs","byte_start":311,"byte_end":312,"line_start":13,"line_end":13,"column_start":51,"column_end":52,"is_primary":true,"text":[{"text":"use crate::hd::{ExtendedPrivateKey, DerivationPath};","highlight_start":51,"highlight_end":52}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `DerivationPath`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ffi.rs:13:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::hd::{ExtendedPrivateKey, DerivationPath};\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `crate::error::WalletError`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/ffi.rs","byte_start":401,"byte_end":426,"line_start":17,"line_end":17,"column_start":5,"column_end":30,"is_primary":true,"text":[{"text":"use crate::error::WalletError;","highlight_start":5,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/ffi.rs","byte_start":397,"byte_end":428,"line_start":17,"line_end":18,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::error::WalletError;","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `crate::error::WalletError`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ffi.rs:17:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m17\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::error::WalletError;\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `bip39::Mnemonic::word_iter`: Use Mnemonic::words instead","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"src/mnemonic.rs","byte_start":2066,"byte_end":2075,"line_start":63,"line_end":63,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"        self.inner.word_iter().collect()","highlight_start":20,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(deprecated)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated method `bip39::Mnemonic::word_iter`: Use Mnemonic::words instead\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/mnemonic.rs:63:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.inner.word_iter().collect()\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(deprecated)]` on by default\n\n"}
{"$message_type":"diagnostic","message":"the method `zeroize_or_on_drop` exists for mutable reference `&mut Network`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hd.rs","byte_start":2400,"byte_end":2413,"line_start":80,"line_end":80,"column_start":10,"column_end":23,"is_primary":true,"text":[{"text":"#[derive(ZeroizeOnDrop)]","highlight_start":10,"highlight_end":23}],"label":"method cannot be called on `&mut Network` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/hd.rs","byte_start":2400,"byte_end":2413,"line_start":80,"line_end":80,"column_start":10,"column_end":23,"is_primary":false,"text":[{"text":"#[derive(ZeroizeOnDrop)]","highlight_start":10,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(ZeroizeOnDrop)]","def_site_span":{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize_derive-1.4.3/src/lib.rs","byte_start":2657,"byte_end":2745,"line_start":95,"line_end":95,"column_start":1,"column_end":89,"is_primary":false,"text":[{"text":"pub fn derive_zeroize_on_drop(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":89}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":1476,"byte_end":1492,"line_start":48,"line_end":48,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"pub enum Network {","highlight_start":1,"highlight_end":17}],"label":"doesn't satisfy `Network: AssertZeroize`, `Network: ZeroizeOnDrop` or `Network: Zeroize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Network: Zeroize`\nwhich is required by `Network: AssertZeroize`\n`Network: ZeroizeOnDrop`\nwhich is required by `&&mut Network: AssertZeroizeOnDrop`\n`&mut Network: Zeroize`\nwhich is required by `&mut Network: AssertZeroize`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the traits `Zeroize` and `ZeroizeOnDrop` must be implemented","code":null,"level":"note","spans":[{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize-1.8.2/src/lib.rs","byte_start":10366,"byte_end":10383,"line_start":272,"line_end":272,"column_start":1,"column_end":18,"is_primary":true,"text":[{"text":"pub trait Zeroize {","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize-1.8.2/src/lib.rs","byte_start":10656,"byte_end":10679,"line_start":279,"line_end":279,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub trait ZeroizeOnDrop {}","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following traits define an item `zeroize_or_on_drop`, perhaps you need to implement one of them:\ncandidate #1: `AssertZeroize`\ncandidate #2: `AssertZeroizeOnDrop`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `zeroize_or_on_drop` exists for mutable reference `&mut Network`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/hd.rs:80:10\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(ZeroizeOnDrop)]\n    \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `&mut Network` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/lib.rs:48:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Network {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Network: AssertZeroize`, `Network: ZeroizeOnDrop` or `Network: Zeroize`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Network: Zeroize`\n            which is required by `Network: AssertZeroize`\n            `Network: ZeroizeOnDrop`\n            which is required by `&&mut Network: AssertZeroizeOnDrop`\n            `&mut Network: Zeroize`\n            which is required by `&mut Network: AssertZeroize`\n\u001b[1m\u001b[92mnote\u001b[0m: the traits `Zeroize` and `ZeroizeOnDrop` must be implemented\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize-1.8.2/src/lib.rs:272:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m272\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Zeroize {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m279\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait ZeroizeOnDrop {}\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is implemented and in scope\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following traits define an item `zeroize_or_on_drop`, perhaps you need to implement one of them:\n            candidate #1: `AssertZeroize`\n            candidate #2: `AssertZeroizeOnDrop`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `ZeroizeOnDrop` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"no field `inner` on type `secp256k1::PublicKey`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hd.rs","byte_start":6200,"byte_end":6205,"line_start":212,"line_end":212,"column_start":31,"column_end":36,"is_primary":true,"text":[{"text":"        self.inner.public_key.inner","highlight_start":31,"highlight_end":36}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `inner` on type `secp256k1::PublicKey`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/hd.rs:212:31\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m212\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.inner.public_key.inner\n    \u001b[1m\u001b[94m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `zeroize_or_on_drop` exists for mutable reference `&mut Network`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hd.rs","byte_start":6887,"byte_end":6900,"line_start":241,"line_end":241,"column_start":10,"column_end":23,"is_primary":true,"text":[{"text":"#[derive(ZeroizeOnDrop)]","highlight_start":10,"highlight_end":23}],"label":"method cannot be called on `&mut Network` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/hd.rs","byte_start":6887,"byte_end":6900,"line_start":241,"line_end":241,"column_start":10,"column_end":23,"is_primary":false,"text":[{"text":"#[derive(ZeroizeOnDrop)]","highlight_start":10,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(ZeroizeOnDrop)]","def_site_span":{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize_derive-1.4.3/src/lib.rs","byte_start":2657,"byte_end":2745,"line_start":95,"line_end":95,"column_start":1,"column_end":89,"is_primary":false,"text":[{"text":"pub fn derive_zeroize_on_drop(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":89}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":1476,"byte_end":1492,"line_start":48,"line_end":48,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"pub enum Network {","highlight_start":1,"highlight_end":17}],"label":"doesn't satisfy `Network: AssertZeroize`, `Network: ZeroizeOnDrop` or `Network: Zeroize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Network: Zeroize`\nwhich is required by `Network: AssertZeroize`\n`Network: ZeroizeOnDrop`\nwhich is required by `&&mut Network: AssertZeroizeOnDrop`\n`&mut Network: Zeroize`\nwhich is required by `&mut Network: AssertZeroize`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the traits `Zeroize` and `ZeroizeOnDrop` must be implemented","code":null,"level":"note","spans":[{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize-1.8.2/src/lib.rs","byte_start":10366,"byte_end":10383,"line_start":272,"line_end":272,"column_start":1,"column_end":18,"is_primary":true,"text":[{"text":"pub trait Zeroize {","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize-1.8.2/src/lib.rs","byte_start":10656,"byte_end":10679,"line_start":279,"line_end":279,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub trait ZeroizeOnDrop {}","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following traits define an item `zeroize_or_on_drop`, perhaps you need to implement one of them:\ncandidate #1: `AssertZeroize`\ncandidate #2: `AssertZeroizeOnDrop`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `zeroize_or_on_drop` exists for mutable reference `&mut Network`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/hd.rs:241:10\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m241\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(ZeroizeOnDrop)]\n    \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `&mut Network` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/lib.rs:48:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m48\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Network {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Network: AssertZeroize`, `Network: ZeroizeOnDrop` or `Network: Zeroize`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Network: Zeroize`\n            which is required by `Network: AssertZeroize`\n            `Network: ZeroizeOnDrop`\n            which is required by `&&mut Network: AssertZeroizeOnDrop`\n            `&mut Network: Zeroize`\n            which is required by `&mut Network: AssertZeroize`\n\u001b[1m\u001b[92mnote\u001b[0m: the traits `Zeroize` and `ZeroizeOnDrop` must be implemented\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize-1.8.2/src/lib.rs:272:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m272\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Zeroize {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m279\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait ZeroizeOnDrop {}\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is implemented and in scope\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following traits define an item `zeroize_or_on_drop`, perhaps you need to implement one of them:\n            candidate #1: `AssertZeroize`\n            candidate #2: `AssertZeroizeOnDrop`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `ZeroizeOnDrop` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `witness_mut` exists for struct `SighashCache<&bitcoin::Transaction>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/btc.rs","byte_start":11090,"byte_end":11101,"line_start":344,"line_end":344,"column_start":27,"column_end":38,"is_primary":true,"text":[{"text":"            sighash_cache.witness_mut(i).unwrap().clone_from(&witness);","highlight_start":27,"highlight_end":38}],"label":"method cannot be called on `SighashCache<&bitcoin::Transaction>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`&bitcoin::Transaction: BorrowMut<bitcoin::Transaction>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `witness_mut` exists for struct `SighashCache<&bitcoin::Transaction>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/btc.rs:344:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m344\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             sighash_cache.witness_mut(i).unwrap().clone_from(&witness);\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `SighashCache<&bitcoin::Transaction>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `&bitcoin::Transaction: BorrowMut<bitcoin::Transaction>`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":4543,"byte_end":4559,"line_start":155,"line_end":155,"column_start":20,"column_end":36,"is_primary":true,"text":[{"text":"            value: tx.value.clone(),","highlight_start":20,"highlight_end":36}],"label":"expected `U256`, found `String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:155:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m155\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             value: tx.value.clone(),\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `U256`, found `String`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":4691,"byte_end":4709,"line_start":159,"line_end":159,"column_start":30,"column_end":48,"is_primary":true,"text":[{"text":"            max_fee_per_gas: tx.max_fee_per_gas,","highlight_start":30,"highlight_end":48}],"label":"expected `Option<U256>`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `std::option::Option<U256>`\n   found type `u64`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:159:30\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m159\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             max_fee_per_gas: tx.max_fee_per_gas,\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<U256>`, found `u64`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `\u001b[1m\u001b[35mstd::option::Option<U256>\u001b[0m`\n               found type `\u001b[1m\u001b[35mu64\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":4749,"byte_end":4776,"line_start":160,"line_end":160,"column_start":39,"column_end":66,"is_primary":true,"text":[{"text":"            max_priority_fee_per_gas: tx.max_priority_fee_per_gas,","highlight_start":39,"highlight_end":66}],"label":"expected `Option<U256>`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `std::option::Option<U256>`\n   found type `u64`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:160:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             max_priority_fee_per_gas: tx.max_priority_fee_per_gas,\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<U256>`, found `u64`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `\u001b[1m\u001b[35mstd::option::Option<U256>\u001b[0m`\n               found type `\u001b[1m\u001b[35mu64\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"missing fields `gas_price` and `tx_type` in initializer of `EthereumTransaction`","code":{"code":"E0063","explanation":"A struct's or struct-like enum variant's field was not provided.\n\nErroneous code example:\n\n```compile_fail,E0063\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0 }; // error: missing field: `y`\n}\n```\n\nEach field should be specified exactly once. Example:\n\n```\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0, y: 0 }; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":4471,"byte_end":4490,"line_start":153,"line_end":153,"column_start":22,"column_end":41,"is_primary":true,"text":[{"text":"        let eth_tx = EthereumTransaction {","highlight_start":22,"highlight_end":41}],"label":"missing `gas_price` and `tx_type`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0063]\u001b[0m\u001b[1m: missing fields `gas_price` and `tx_type` in initializer of `EthereumTransaction`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:153:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m153\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let eth_tx = EthereumTransaction {\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmissing `gas_price` and `tx_type`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `raw_tx` on type `SignedEthereumTransaction`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":5005,"byte_end":5011,"line_start":168,"line_end":168,"column_start":28,"column_end":34,"is_primary":true,"text":[{"text":"            raw_tx: signed.raw_tx,","highlight_start":28,"highlight_end":34}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a field with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/evm.rs","byte_start":5005,"byte_end":5011,"line_start":168,"line_end":168,"column_start":28,"column_end":34,"is_primary":true,"text":[{"text":"            raw_tx: signed.raw_tx,","highlight_start":28,"highlight_end":34}],"label":null,"suggested_replacement":"raw_hex","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `raw_tx` on type `SignedEthereumTransaction`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:168:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m168\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             raw_tx: signed.raw_tx,\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a field with a similar name exists\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m168\u001b[0m \u001b[91m- \u001b[0m            raw_tx: signed.\u001b[91mraw_tx\u001b[0m,\n\u001b[1m\u001b[94m168\u001b[0m \u001b[92m+ \u001b[0m            raw_tx: signed.\u001b[92mraw_hex\u001b[0m,\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `tx_hash` on type `SignedEthereumTransaction`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":5041,"byte_end":5048,"line_start":169,"line_end":169,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"            tx_hash: signed.tx_hash,","highlight_start":29,"highlight_end":36}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `raw_hex`, `hash`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `tx_hash` on type `SignedEthereumTransaction`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:169:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m169\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             tx_hash: signed.tx_hash,\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `raw_hex`, `hash`\n\n"}
{"$message_type":"diagnostic","message":"no field `from` on type `SignedEthereumTransaction`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":5075,"byte_end":5079,"line_start":170,"line_end":170,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"            from: signed.from,","highlight_start":26,"highlight_end":30}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `raw_hex`, `hash`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `from` on type `SignedEthereumTransaction`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:170:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m170\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             from: signed.from,\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `raw_hex`, `hash`\n\n"}
{"$message_type":"diagnostic","message":"no method named `fingerprint` found for struct `EthereumWallet` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":5264,"byte_end":5275,"line_start":178,"line_end":178,"column_start":20,"column_end":31,"is_primary":true,"text":[{"text":"        self.inner.fingerprint()","highlight_start":20,"highlight_end":31}],"label":"method not found in `EthereumWallet`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/eth.rs","byte_start":7731,"byte_end":7756,"line_start":258,"line_end":258,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"pub struct EthereumWallet {","highlight_start":1,"highlight_end":26}],"label":"method `fingerprint` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `fingerprint` found for struct `EthereumWallet` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:178:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m178\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.inner.fingerprint()\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `EthereumWallet`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/eth.rs:258:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m258\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct EthereumWallet {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-------------------------\u001b[0m \u001b[1m\u001b[94mmethod `fingerprint` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `message` on type `&SolanaTransaction`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/sol.rs","byte_start":4790,"byte_end":4797,"line_start":154,"line_end":154,"column_start":59,"column_end":66,"is_primary":true,"text":[{"text":"        let signature = sign_ed25519(&keypair.secret, &tx.message)?;","highlight_start":59,"highlight_end":66}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `to`, `lamports`, `recent_blockhash`, `memo`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `message` on type `&SolanaTransaction`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/sol.rs:154:59\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m154\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let signature = sign_ed25519(&keypair.secret, &tx.message)?;\n    \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `to`, `lamports`, `recent_blockhash`, `memo`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/sol.rs","byte_start":5311,"byte_end":5349,"line_start":169,"line_end":169,"column_start":9,"column_end":47,"is_primary":true,"text":[{"text":"        sign_ed25519(&keypair.secret, message)","highlight_start":9,"highlight_end":47}],"label":"expected `Result<Vec<u8>, WalletError>`, found `Result<[u8; 64], WalletError>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/sol.rs","byte_start":5221,"byte_end":5236,"line_start":167,"line_end":167,"column_start":68,"column_end":83,"is_primary":false,"text":[{"text":"    pub fn sign_message(&self, message: &[u8], from_index: u32) -> Result<Vec<u8>> {","highlight_start":68,"highlight_end":83}],"label":"expected `std::result::Result<Vec<u8>, WalletError>` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `std::result::Result<Vec<u8>, _>`\n   found enum `std::result::Result<[u8; 64], _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/sol.rs:169:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m167\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn sign_message(&self, message: &[u8], from_index: u32) -> Result<Vec<u8>> {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                    \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mexpected `std::result::Result<Vec<u8>, WalletError>` because of return type\u001b[0m\n\u001b[1m\u001b[94m168\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let keypair = self.derive_ed25519_keypair(from_index)?;\n\u001b[1m\u001b[94m169\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         sign_ed25519(&keypair.secret, message)\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Result<Vec<u8>, WalletError>`, found `Result<[u8; 64], WalletError>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `std::result::Result<\u001b[1m\u001b[35mVec<u8>\u001b[0m, _>`\n               found enum `std::result::Result<\u001b[1m\u001b[35m[u8; 64]\u001b[0m, _>`\n\n"}
{"$message_type":"diagnostic","message":"`QrCode` doesn't implement `Debug`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/airgap.rs","byte_start":6179,"byte_end":6191,"line_start":196,"line_end":196,"column_start":5,"column_end":17,"is_primary":true,"text":[{"text":"    code: QrCode,","highlight_start":5,"highlight_end":17}],"label":"the trait `Debug` is not implemented for `QrCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/airgap.rs","byte_start":5933,"byte_end":5938,"line_start":187,"line_end":187,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: `QrCode` doesn't implement `Debug`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/airgap.rs:196:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m187\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m196\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     code: QrCode,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Debug` is not implemented for `QrCode`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `e`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/btc.rs","byte_start":2004,"byte_end":2005,"line_start":66,"line_end":66,"column_start":23,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| WalletError::InvalidPublicKey)?;","highlight_start":23,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/btc.rs","byte_start":2004,"byte_end":2005,"line_start":66,"line_end":66,"column_start":23,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| WalletError::InvalidPublicKey)?;","highlight_start":23,"highlight_end":24}],"label":null,"suggested_replacement":"_e","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `e`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/btc.rs:66:23\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m66\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .map_err(|e| WalletError::InvalidPublicKey)?;\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[33m^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_e`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `network`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/btc.rs","byte_start":2439,"byte_end":2446,"line_start":81,"line_end":81,"column_start":33,"column_end":40,"is_primary":true,"text":[{"text":"    pub fn parse(address: &str, network: Network) -> Result<Address<bitcoin::address::NetworkUnchecked>> {","highlight_start":33,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/btc.rs","byte_start":2439,"byte_end":2446,"line_start":81,"line_end":81,"column_start":33,"column_end":40,"is_primary":true,"text":[{"text":"    pub fn parse(address: &str, network: Network) -> Result<Address<bitcoin::address::NetworkUnchecked>> {","highlight_start":33,"highlight_end":40}],"label":null,"suggested_replacement":"_network","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `network`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/btc.rs:81:33\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn parse(address: &str, network: Network) -> Result<Address<bitcoin::address::NetworkUnchecked>> {\n   \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[33m^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_network`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `i`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/eth.rs","byte_start":2976,"byte_end":2977,"line_start":96,"line_end":96,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"        for (i, (c, h)) in addr.chars().zip(hash_hex.chars()).enumerate() {","highlight_start":14,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/eth.rs","byte_start":2976,"byte_end":2977,"line_start":96,"line_end":96,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"        for (i, (c, h)) in addr.chars().zip(hash_hex.chars()).enumerate() {","highlight_start":14,"highlight_end":15}],"label":null,"suggested_replacement":"_i","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `i`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/eth.rs:96:14\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for (i, (c, h)) in addr.chars().zip(hash_hex.chars()).enumerate() {\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[33m^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_i`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 15 previous errors; 13 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 15 previous errors; 13 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0063, E0277, E0308, E0599, E0609.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0063, E0277, E0308, E0599, E0609.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0063`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0063`.\u001b[0m\n"}
