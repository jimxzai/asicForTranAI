{"$message_type":"diagnostic","message":"unused import: `ChildNumber`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/hd.rs","byte_start":231,"byte_end":242,"line_start":9,"line_end":9,"column_start":5,"column_end":16,"is_primary":true,"text":[{"text":"    ChildNumber,","highlight_start":5,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/hd.rs","byte_start":225,"byte_end":242,"line_start":8,"line_end":9,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    Xpriv, Xpub,","highlight_start":16,"highlight_end":17},{"text":"    ChildNumber,","highlight_start":1,"highlight_end":16}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `ChildNumber`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/hd.rs:9:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     ChildNumber,\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused import: `Zeroize`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/hd.rs","byte_start":337,"byte_end":344,"line_start":13,"line_end":13,"column_start":15,"column_end":22,"is_primary":true,"text":[{"text":"use zeroize::{Zeroize, ZeroizeOnDrop};","highlight_start":15,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/hd.rs","byte_start":337,"byte_end":346,"line_start":13,"line_end":13,"column_start":15,"column_end":24,"is_primary":true,"text":[{"text":"use zeroize::{Zeroize, ZeroizeOnDrop};","highlight_start":15,"highlight_end":24}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/hd.rs","byte_start":336,"byte_end":337,"line_start":13,"line_end":13,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"use zeroize::{Zeroize, ZeroizeOnDrop};","highlight_start":14,"highlight_end":15}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/hd.rs","byte_start":359,"byte_end":360,"line_start":13,"line_end":13,"column_start":37,"column_end":38,"is_primary":true,"text":[{"text":"use zeroize::{Zeroize, ZeroizeOnDrop};","highlight_start":37,"highlight_end":38}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `Zeroize`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hd.rs:13:15\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use zeroize::{Zeroize, ZeroizeOnDrop};\n   \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[33m^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `PublicKey as BtcPublicKey`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/btc.rs","byte_start":215,"byte_end":240,"line_start":7,"line_end":7,"column_start":37,"column_end":62,"is_primary":true,"text":[{"text":"    Address, Network as BtcNetwork, PublicKey as BtcPublicKey,","highlight_start":37,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/btc.rs","byte_start":213,"byte_end":240,"line_start":7,"line_end":7,"column_start":35,"column_end":62,"is_primary":true,"text":[{"text":"    Address, Network as BtcNetwork, PublicKey as BtcPublicKey,","highlight_start":35,"highlight_end":62}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `PublicKey as BtcPublicKey`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/btc.rs:7:37\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Address, Network as BtcNetwork, PublicKey as BtcPublicKey,\n  \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `SecretKey`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/btc.rs","byte_start":528,"byte_end":537,"line_start":16,"line_end":16,"column_start":37,"column_end":46,"is_primary":true,"text":[{"text":"use secp256k1::{Secp256k1, Message, SecretKey};","highlight_start":37,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/btc.rs","byte_start":526,"byte_end":537,"line_start":16,"line_end":16,"column_start":35,"column_end":46,"is_primary":true,"text":[{"text":"use secp256k1::{Secp256k1, Message, SecretKey};","highlight_start":35,"highlight_end":46}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `SecretKey`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/btc.rs:16:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use secp256k1::{Secp256k1, Message, SecretKey};\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused imports: `SecretKey`, `ecdsa::RecoverableSignature`, and `ecdsa::RecoveryId`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/eth.rs","byte_start":279,"byte_end":288,"line_start":9,"line_end":9,"column_start":37,"column_end":46,"is_primary":true,"text":[{"text":"use secp256k1::{Secp256k1, Message, SecretKey, ecdsa::RecoverableSignature, ecdsa::RecoveryId};","highlight_start":37,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/eth.rs","byte_start":290,"byte_end":317,"line_start":9,"line_end":9,"column_start":48,"column_end":75,"is_primary":true,"text":[{"text":"use secp256k1::{Secp256k1, Message, SecretKey, ecdsa::RecoverableSignature, ecdsa::RecoveryId};","highlight_start":48,"highlight_end":75}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/eth.rs","byte_start":319,"byte_end":336,"line_start":9,"line_end":9,"column_start":77,"column_end":94,"is_primary":true,"text":[{"text":"use secp256k1::{Secp256k1, Message, SecretKey, ecdsa::RecoverableSignature, ecdsa::RecoveryId};","highlight_start":77,"highlight_end":94}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused imports","code":null,"level":"help","spans":[{"file_name":"src/eth.rs","byte_start":277,"byte_end":336,"line_start":9,"line_end":9,"column_start":35,"column_end":94,"is_primary":true,"text":[{"text":"use secp256k1::{Secp256k1, Message, SecretKey, ecdsa::RecoverableSignature, ecdsa::RecoveryId};","highlight_start":35,"highlight_end":94}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused imports: `SecretKey`, `ecdsa::RecoverableSignature`, and `ecdsa::RecoveryId`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/eth.rs:9:37\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m9\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use secp256k1::{Secp256k1, Message, SecretKey, ecdsa::RecoverableSignature, ecdsa::RecoveryId};\n  \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m  \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `SignedEthereumTransaction`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/evm.rs","byte_start":436,"byte_end":461,"line_start":14,"line_end":14,"column_start":72,"column_end":97,"is_primary":true,"text":[{"text":"use crate::eth::{EthereumWallet, EthereumAddress, EthereumTransaction, SignedEthereumTransaction};","highlight_start":72,"highlight_end":97}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/evm.rs","byte_start":434,"byte_end":461,"line_start":14,"line_end":14,"column_start":70,"column_end":97,"is_primary":true,"text":[{"text":"use crate::eth::{EthereumWallet, EthereumAddress, EthereumTransaction, SignedEthereumTransaction};","highlight_start":70,"highlight_end":97}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `SignedEthereumTransaction`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:14:72\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m14\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::eth::{EthereumWallet, EthereumAddress, EthereumTransaction, SignedEthereumTransaction};\n   \u001b[1m\u001b[94m|\u001b[0m                                                                        \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `WalletError`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/evm.rs","byte_start":518,"byte_end":529,"line_start":16,"line_end":16,"column_start":20,"column_end":31,"is_primary":true,"text":[{"text":"use crate::error::{WalletError, Result};","highlight_start":20,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/evm.rs","byte_start":518,"byte_end":531,"line_start":16,"line_end":16,"column_start":20,"column_end":33,"is_primary":true,"text":[{"text":"use crate::error::{WalletError, Result};","highlight_start":20,"highlight_end":33}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/evm.rs","byte_start":517,"byte_end":518,"line_start":16,"line_end":16,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"use crate::error::{WalletError, Result};","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/evm.rs","byte_start":537,"byte_end":538,"line_start":16,"line_end":16,"column_start":39,"column_end":40,"is_primary":true,"text":[{"text":"use crate::error::{WalletError, Result};","highlight_start":39,"highlight_end":40}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `WalletError`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:16:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m16\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::error::{WalletError, Result};\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[33m^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `DerivationPath`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/ffi.rs","byte_start":297,"byte_end":311,"line_start":13,"line_end":13,"column_start":37,"column_end":51,"is_primary":true,"text":[{"text":"use crate::hd::{ExtendedPrivateKey, DerivationPath};","highlight_start":37,"highlight_end":51}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/ffi.rs","byte_start":295,"byte_end":311,"line_start":13,"line_end":13,"column_start":35,"column_end":51,"is_primary":true,"text":[{"text":"use crate::hd::{ExtendedPrivateKey, DerivationPath};","highlight_start":35,"highlight_end":51}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/ffi.rs","byte_start":276,"byte_end":277,"line_start":13,"line_end":13,"column_start":16,"column_end":17,"is_primary":true,"text":[{"text":"use crate::hd::{ExtendedPrivateKey, DerivationPath};","highlight_start":16,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/ffi.rs","byte_start":311,"byte_end":312,"line_start":13,"line_end":13,"column_start":51,"column_end":52,"is_primary":true,"text":[{"text":"use crate::hd::{ExtendedPrivateKey, DerivationPath};","highlight_start":51,"highlight_end":52}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `DerivationPath`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ffi.rs:13:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m13\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::hd::{ExtendedPrivateKey, DerivationPath};\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[33m^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `crate::error::WalletError`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/ffi.rs","byte_start":401,"byte_end":426,"line_start":17,"line_end":17,"column_start":5,"column_end":30,"is_primary":true,"text":[{"text":"use crate::error::WalletError;","highlight_start":5,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/ffi.rs","byte_start":397,"byte_end":428,"line_start":17,"line_end":18,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::error::WalletError;","highlight_start":1,"highlight_end":31},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `crate::error::WalletError`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/ffi.rs:17:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m17\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::error::WalletError;\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `generate` found for struct `bip39::Mnemonic` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/mnemonic.rs","byte_start":703,"byte_end":711,"line_start":22,"line_end":22,"column_start":39,"column_end":47,"is_primary":true,"text":[{"text":"        let mnemonic = Bip39Mnemonic::generate(24)","highlight_start":39,"highlight_end":47}],"label":"function or associated item not found in `bip39::Mnemonic`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `bip39::Mnemonic` consider using one of the following associated functions:\nbip39::Mnemonic::from_entropy_in\nbip39::Mnemonic::from_entropy\nbip39::Mnemonic::parse_in_normalized\nbip39::Mnemonic::parse_in_normalized_without_checksum_check\nand 3 others","code":null,"level":"note","spans":[{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bip39-2.2.2/src/lib.rs","byte_start":6265,"byte_end":6350,"line_start":207,"line_end":207,"column_start":2,"column_end":87,"is_primary":true,"text":[{"text":"\tpub fn from_entropy_in(language: Language, entropy: &[u8]) -> Result<Mnemonic, Error> {","highlight_start":2,"highlight_end":87}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bip39-2.2.2/src/lib.rs","byte_start":7487,"byte_end":7549,"line_start":253,"line_end":253,"column_start":2,"column_end":64,"is_primary":true,"text":[{"text":"\tpub fn from_entropy(entropy: &[u8]) -> Result<Mnemonic, Error> {","highlight_start":2,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bip39-2.2.2/src/lib.rs","byte_start":13323,"byte_end":13405,"line_start":437,"line_end":437,"column_start":2,"column_end":84,"is_primary":true,"text":[{"text":"\tpub fn parse_in_normalized(language: Language, s: &str) -> Result<Mnemonic, Error> {","highlight_start":2,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bip39-2.2.2/src/lib.rs","byte_start":14871,"byte_end":14984,"line_start":489,"line_end":492,"column_start":2,"column_end":30,"is_primary":true,"text":[{"text":"\tpub fn parse_in_normalized_without_checksum_check(","highlight_start":2,"highlight_end":52},{"text":"\t\tlanguage: Language,","highlight_start":1,"highlight_end":22},{"text":"\t\ts: &str,","highlight_start":1,"highlight_end":11},{"text":"\t) -> Result<Mnemonic, Error> {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `generate` found for struct `bip39::Mnemonic` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/mnemonic.rs:22:39\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mnemonic = Bip39Mnemonic::generate(24)\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `bip39::Mnemonic`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `bip39::Mnemonic` consider using one of the following associated functions:\n      bip39::Mnemonic::from_entropy_in\n      bip39::Mnemonic::from_entropy\n      bip39::Mnemonic::parse_in_normalized\n      bip39::Mnemonic::parse_in_normalized_without_checksum_check\n      and 3 others\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bip39-2.2.2/src/lib.rs:207:2\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m207\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       pub fn from_entropy_in(language: Language, entropy: &[u8]) -> Result<Mnemonic, Error> {\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m253\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       pub fn from_entropy(entropy: &[u8]) -> Result<Mnemonic, Error> {\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m437\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       pub fn parse_in_normalized(language: Language, s: &str) -> Result<Mnemonic, Error> {\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m489\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m     pub fn parse_in_normalized_without_checksum_check(\n\u001b[1m\u001b[94m490\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         language: Language,\n\u001b[1m\u001b[94m491\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         s: &str,\n\u001b[1m\u001b[94m492\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ) -> Result<Mnemonic, Error> {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|________________________________^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/mnemonic.rs","byte_start":770,"byte_end":771,"line_start":23,"line_end":23,"column_start":55,"column_end":56,"is_primary":false,"text":[{"text":"            .map_err(|e| WalletError::InvalidMnemonic(e.to_string()))?;","highlight_start":55,"highlight_end":56}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/mnemonic.rs","byte_start":738,"byte_end":739,"line_start":23,"line_end":23,"column_start":23,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| WalletError::InvalidMnemonic(e.to_string()))?;","highlight_start":23,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/mnemonic.rs","byte_start":739,"byte_end":739,"line_start":23,"line_end":23,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| WalletError::InvalidMnemonic(e.to_string()))?;","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/mnemonic.rs:23:23\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .map_err(|e| WalletError::InvalidMnemonic(e.to_string()))?;\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^\u001b[0m                               \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            .map_err(|e\u001b[92m: /* Type */\u001b[0m| WalletError::InvalidMnemonic(e.to_string()))?;\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `generate` found for struct `bip39::Mnemonic` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/mnemonic.rs","byte_start":1208,"byte_end":1216,"line_start":36,"line_end":36,"column_start":39,"column_end":47,"is_primary":true,"text":[{"text":"        let mnemonic = Bip39Mnemonic::generate(word_count)","highlight_start":39,"highlight_end":47}],"label":"function or associated item not found in `bip39::Mnemonic`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `bip39::Mnemonic` consider using one of the following associated functions:\nbip39::Mnemonic::from_entropy_in\nbip39::Mnemonic::from_entropy\nbip39::Mnemonic::parse_in_normalized\nbip39::Mnemonic::parse_in_normalized_without_checksum_check\nand 3 others","code":null,"level":"note","spans":[{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bip39-2.2.2/src/lib.rs","byte_start":6265,"byte_end":6350,"line_start":207,"line_end":207,"column_start":2,"column_end":87,"is_primary":true,"text":[{"text":"\tpub fn from_entropy_in(language: Language, entropy: &[u8]) -> Result<Mnemonic, Error> {","highlight_start":2,"highlight_end":87}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bip39-2.2.2/src/lib.rs","byte_start":7487,"byte_end":7549,"line_start":253,"line_end":253,"column_start":2,"column_end":64,"is_primary":true,"text":[{"text":"\tpub fn from_entropy(entropy: &[u8]) -> Result<Mnemonic, Error> {","highlight_start":2,"highlight_end":64}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bip39-2.2.2/src/lib.rs","byte_start":13323,"byte_end":13405,"line_start":437,"line_end":437,"column_start":2,"column_end":84,"is_primary":true,"text":[{"text":"\tpub fn parse_in_normalized(language: Language, s: &str) -> Result<Mnemonic, Error> {","highlight_start":2,"highlight_end":84}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bip39-2.2.2/src/lib.rs","byte_start":14871,"byte_end":14984,"line_start":489,"line_end":492,"column_start":2,"column_end":30,"is_primary":true,"text":[{"text":"\tpub fn parse_in_normalized_without_checksum_check(","highlight_start":2,"highlight_end":52},{"text":"\t\tlanguage: Language,","highlight_start":1,"highlight_end":22},{"text":"\t\ts: &str,","highlight_start":1,"highlight_end":11},{"text":"\t) -> Result<Mnemonic, Error> {","highlight_start":1,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `generate` found for struct `bip39::Mnemonic` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/mnemonic.rs:36:39\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m36\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mnemonic = Bip39Mnemonic::generate(word_count)\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `bip39::Mnemonic`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `bip39::Mnemonic` consider using one of the following associated functions:\n      bip39::Mnemonic::from_entropy_in\n      bip39::Mnemonic::from_entropy\n      bip39::Mnemonic::parse_in_normalized\n      bip39::Mnemonic::parse_in_normalized_without_checksum_check\n      and 3 others\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/bip39-2.2.2/src/lib.rs:207:2\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m207\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       pub fn from_entropy_in(language: Language, entropy: &[u8]) -> Result<Mnemonic, Error> {\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m253\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       pub fn from_entropy(entropy: &[u8]) -> Result<Mnemonic, Error> {\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m437\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       pub fn parse_in_normalized(language: Language, s: &str) -> Result<Mnemonic, Error> {\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m489\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m     pub fn parse_in_normalized_without_checksum_check(\n\u001b[1m\u001b[94m490\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         language: Language,\n\u001b[1m\u001b[94m491\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         s: &str,\n\u001b[1m\u001b[94m492\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ) -> Result<Mnemonic, Error> {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|________________________________^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/mnemonic.rs","byte_start":1283,"byte_end":1284,"line_start":37,"line_end":37,"column_start":55,"column_end":56,"is_primary":false,"text":[{"text":"            .map_err(|e| WalletError::InvalidMnemonic(e.to_string()))?;","highlight_start":55,"highlight_end":56}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/mnemonic.rs","byte_start":1251,"byte_end":1252,"line_start":37,"line_end":37,"column_start":23,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| WalletError::InvalidMnemonic(e.to_string()))?;","highlight_start":23,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/mnemonic.rs","byte_start":1252,"byte_end":1252,"line_start":37,"line_end":37,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| WalletError::InvalidMnemonic(e.to_string()))?;","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/mnemonic.rs:37:23\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .map_err(|e| WalletError::InvalidMnemonic(e.to_string()))?;\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^\u001b[0m                               \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            .map_err(|e\u001b[92m: /* Type */\u001b[0m| WalletError::InvalidMnemonic(e.to_string()))?;\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `as_str` found for struct `bip39::Mnemonic` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/mnemonic.rs","byte_start":1892,"byte_end":1898,"line_start":58,"line_end":58,"column_start":20,"column_end":26,"is_primary":true,"text":[{"text":"        self.inner.as_str()","highlight_start":20,"highlight_end":26}],"label":"method not found in `bip39::Mnemonic`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `as_str` found for struct `bip39::Mnemonic` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/mnemonic.rs:58:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.inner.as_str()\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `bip39::Mnemonic`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `bip39::Mnemonic::word_iter`: Use Mnemonic::words instead","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"src/mnemonic.rs","byte_start":1995,"byte_end":2004,"line_start":63,"line_end":63,"column_start":20,"column_end":29,"is_primary":true,"text":[{"text":"        self.inner.word_iter().collect()","highlight_start":20,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(deprecated)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated method `bip39::Mnemonic::word_iter`: Use Mnemonic::words instead\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/mnemonic.rs:63:20\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.inner.word_iter().collect()\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(deprecated)]` on by default\n\n"}
{"$message_type":"diagnostic","message":"the method `zeroize_or_on_drop` exists for mutable reference `&mut Network`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hd.rs","byte_start":2400,"byte_end":2413,"line_start":80,"line_end":80,"column_start":10,"column_end":23,"is_primary":true,"text":[{"text":"#[derive(ZeroizeOnDrop)]","highlight_start":10,"highlight_end":23}],"label":"method cannot be called on `&mut Network` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/hd.rs","byte_start":2400,"byte_end":2413,"line_start":80,"line_end":80,"column_start":10,"column_end":23,"is_primary":false,"text":[{"text":"#[derive(ZeroizeOnDrop)]","highlight_start":10,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(ZeroizeOnDrop)]","def_site_span":{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize_derive-1.4.3/src/lib.rs","byte_start":2657,"byte_end":2745,"line_start":95,"line_end":95,"column_start":1,"column_end":89,"is_primary":false,"text":[{"text":"pub fn derive_zeroize_on_drop(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":89}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":1414,"byte_end":1430,"line_start":46,"line_end":46,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"pub enum Network {","highlight_start":1,"highlight_end":17}],"label":"doesn't satisfy `Network: AssertZeroize`, `Network: ZeroizeOnDrop` or `Network: Zeroize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Network: Zeroize`\nwhich is required by `Network: AssertZeroize`\n`Network: ZeroizeOnDrop`\nwhich is required by `&&mut Network: AssertZeroizeOnDrop`\n`&mut Network: Zeroize`\nwhich is required by `&mut Network: AssertZeroize`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the traits `Zeroize` and `ZeroizeOnDrop` must be implemented","code":null,"level":"note","spans":[{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize-1.8.2/src/lib.rs","byte_start":10366,"byte_end":10383,"line_start":272,"line_end":272,"column_start":1,"column_end":18,"is_primary":true,"text":[{"text":"pub trait Zeroize {","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize-1.8.2/src/lib.rs","byte_start":10656,"byte_end":10679,"line_start":279,"line_end":279,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub trait ZeroizeOnDrop {}","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following traits define an item `zeroize_or_on_drop`, perhaps you need to implement one of them:\ncandidate #1: `AssertZeroize`\ncandidate #2: `AssertZeroizeOnDrop`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `zeroize_or_on_drop` exists for mutable reference `&mut Network`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/hd.rs:80:10\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(ZeroizeOnDrop)]\n    \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `&mut Network` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/lib.rs:46:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Network {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Network: AssertZeroize`, `Network: ZeroizeOnDrop` or `Network: Zeroize`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Network: Zeroize`\n            which is required by `Network: AssertZeroize`\n            `Network: ZeroizeOnDrop`\n            which is required by `&&mut Network: AssertZeroizeOnDrop`\n            `&mut Network: Zeroize`\n            which is required by `&mut Network: AssertZeroize`\n\u001b[1m\u001b[92mnote\u001b[0m: the traits `Zeroize` and `ZeroizeOnDrop` must be implemented\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize-1.8.2/src/lib.rs:272:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m272\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Zeroize {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m279\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait ZeroizeOnDrop {}\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is implemented and in scope\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following traits define an item `zeroize_or_on_drop`, perhaps you need to implement one of them:\n            candidate #1: `AssertZeroize`\n            candidate #2: `AssertZeroizeOnDrop`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `ZeroizeOnDrop` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"no field `inner` on type `secp256k1::PublicKey`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hd.rs","byte_start":5411,"byte_end":5416,"line_start":183,"line_end":183,"column_start":31,"column_end":36,"is_primary":true,"text":[{"text":"        self.inner.public_key.inner","highlight_start":31,"highlight_end":36}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `inner` on type `secp256k1::PublicKey`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/hd.rs:183:31\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m183\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.inner.public_key.inner\n    \u001b[1m\u001b[94m|\u001b[0m                               \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `zeroize_or_on_drop` exists for mutable reference `&mut Network`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hd.rs","byte_start":6098,"byte_end":6111,"line_start":212,"line_end":212,"column_start":10,"column_end":23,"is_primary":true,"text":[{"text":"#[derive(ZeroizeOnDrop)]","highlight_start":10,"highlight_end":23}],"label":"method cannot be called on `&mut Network` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/hd.rs","byte_start":6098,"byte_end":6111,"line_start":212,"line_end":212,"column_start":10,"column_end":23,"is_primary":false,"text":[{"text":"#[derive(ZeroizeOnDrop)]","highlight_start":10,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(ZeroizeOnDrop)]","def_site_span":{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize_derive-1.4.3/src/lib.rs","byte_start":2657,"byte_end":2745,"line_start":95,"line_end":95,"column_start":1,"column_end":89,"is_primary":false,"text":[{"text":"pub fn derive_zeroize_on_drop(input: proc_macro::TokenStream) -> proc_macro::TokenStream {","highlight_start":1,"highlight_end":89}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/lib.rs","byte_start":1414,"byte_end":1430,"line_start":46,"line_end":46,"column_start":1,"column_end":17,"is_primary":false,"text":[{"text":"pub enum Network {","highlight_start":1,"highlight_end":17}],"label":"doesn't satisfy `Network: AssertZeroize`, `Network: ZeroizeOnDrop` or `Network: Zeroize`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Network: Zeroize`\nwhich is required by `Network: AssertZeroize`\n`Network: ZeroizeOnDrop`\nwhich is required by `&&mut Network: AssertZeroizeOnDrop`\n`&mut Network: Zeroize`\nwhich is required by `&mut Network: AssertZeroize`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the traits `Zeroize` and `ZeroizeOnDrop` must be implemented","code":null,"level":"note","spans":[{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize-1.8.2/src/lib.rs","byte_start":10366,"byte_end":10383,"line_start":272,"line_end":272,"column_start":1,"column_end":18,"is_primary":true,"text":[{"text":"pub trait Zeroize {","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize-1.8.2/src/lib.rs","byte_start":10656,"byte_end":10679,"line_start":279,"line_end":279,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"pub trait ZeroizeOnDrop {}","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following traits define an item `zeroize_or_on_drop`, perhaps you need to implement one of them:\ncandidate #1: `AssertZeroize`\ncandidate #2: `AssertZeroizeOnDrop`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `zeroize_or_on_drop` exists for mutable reference `&mut Network`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/hd.rs:212:10\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m212\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(ZeroizeOnDrop)]\n    \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `&mut Network` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/lib.rs:46:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Network {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Network: AssertZeroize`, `Network: ZeroizeOnDrop` or `Network: Zeroize`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Network: Zeroize`\n            which is required by `Network: AssertZeroize`\n            `Network: ZeroizeOnDrop`\n            which is required by `&&mut Network: AssertZeroizeOnDrop`\n            `&mut Network: Zeroize`\n            which is required by `&mut Network: AssertZeroize`\n\u001b[1m\u001b[92mnote\u001b[0m: the traits `Zeroize` and `ZeroizeOnDrop` must be implemented\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/zeroize-1.8.2/src/lib.rs:272:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m272\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait Zeroize {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m279\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub trait ZeroizeOnDrop {}\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is implemented and in scope\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following traits define an item `zeroize_or_on_drop`, perhaps you need to implement one of them:\n            candidate #1: `AssertZeroize`\n            candidate #2: `AssertZeroizeOnDrop`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `ZeroizeOnDrop` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `witness_mut` exists for struct `SighashCache<&bitcoin::Transaction>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/btc.rs","byte_start":10753,"byte_end":10764,"line_start":333,"line_end":333,"column_start":27,"column_end":38,"is_primary":true,"text":[{"text":"            sighash_cache.witness_mut(i).unwrap().clone_from(&witness);","highlight_start":27,"highlight_end":38}],"label":"method cannot be called on `SighashCache<&bitcoin::Transaction>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`&bitcoin::Transaction: BorrowMut<bitcoin::Transaction>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `witness_mut` exists for struct `SighashCache<&bitcoin::Transaction>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/btc.rs:333:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m333\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             sighash_cache.witness_mut(i).unwrap().clone_from(&witness);\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `SighashCache<&bitcoin::Transaction>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `&bitcoin::Transaction: BorrowMut<bitcoin::Transaction>`\n\n"}
{"$message_type":"diagnostic","message":"no method named `get_all_addresses` found for struct `eth::EthereumWallet` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/eth.rs","byte_start":7731,"byte_end":7756,"line_start":258,"line_end":258,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"pub struct EthereumWallet {","highlight_start":1,"highlight_end":26}],"label":"method `get_all_addresses` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/evm.rs","byte_start":4190,"byte_end":4207,"line_start":143,"line_end":143,"column_start":20,"column_end":37,"is_primary":true,"text":[{"text":"        self.inner.get_all_addresses()","highlight_start":20,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `get_address` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"src/eth.rs","byte_start":8620,"byte_end":8684,"line_start":289,"line_end":289,"column_start":5,"column_end":69,"is_primary":true,"text":[{"text":"    pub fn get_address(&self, index: u32) -> Result<EthereumAddress> {","highlight_start":5,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `get_all_addresses` found for struct `eth::EthereumWallet` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:143:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m143\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.inner.get_all_addresses()\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/eth.rs:258:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m258\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct EthereumWallet {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-------------------------\u001b[0m \u001b[1m\u001b[94mmethod `get_all_addresses` not found for this struct\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `get_address` with a similar name, but with different arguments\n   \u001b[1m\u001b[94m--> \u001b[0msrc/eth.rs:289:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m289\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn get_address(&self, index: u32) -> Result<EthereumAddress> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":4543,"byte_end":4559,"line_start":155,"line_end":155,"column_start":20,"column_end":36,"is_primary":true,"text":[{"text":"            value: tx.value.clone(),","highlight_start":20,"highlight_end":36}],"label":"expected `U256`, found `String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:155:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m155\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             value: tx.value.clone(),\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `U256`, found `String`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":4691,"byte_end":4709,"line_start":159,"line_end":159,"column_start":30,"column_end":48,"is_primary":true,"text":[{"text":"            max_fee_per_gas: tx.max_fee_per_gas,","highlight_start":30,"highlight_end":48}],"label":"expected `Option<U256>`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `std::option::Option<U256>`\n   found type `u64`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:159:30\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m159\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             max_fee_per_gas: tx.max_fee_per_gas,\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<U256>`, found `u64`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `\u001b[1m\u001b[35mstd::option::Option<U256>\u001b[0m`\n               found type `\u001b[1m\u001b[35mu64\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":4749,"byte_end":4776,"line_start":160,"line_end":160,"column_start":39,"column_end":66,"is_primary":true,"text":[{"text":"            max_priority_fee_per_gas: tx.max_priority_fee_per_gas,","highlight_start":39,"highlight_end":66}],"label":"expected `Option<U256>`, found `u64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `std::option::Option<U256>`\n   found type `u64`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:160:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m160\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             max_priority_fee_per_gas: tx.max_priority_fee_per_gas,\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Option<U256>`, found `u64`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `\u001b[1m\u001b[35mstd::option::Option<U256>\u001b[0m`\n               found type `\u001b[1m\u001b[35mu64\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"missing fields `gas_price` and `tx_type` in initializer of `eth::EthereumTransaction`","code":{"code":"E0063","explanation":"A struct's or struct-like enum variant's field was not provided.\n\nErroneous code example:\n\n```compile_fail,E0063\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0 }; // error: missing field: `y`\n}\n```\n\nEach field should be specified exactly once. Example:\n\n```\nstruct Foo {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let x = Foo { x: 0, y: 0 }; // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":4471,"byte_end":4490,"line_start":153,"line_end":153,"column_start":22,"column_end":41,"is_primary":true,"text":[{"text":"        let eth_tx = EthereumTransaction {","highlight_start":22,"highlight_end":41}],"label":"missing `gas_price` and `tx_type`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0063]\u001b[0m\u001b[1m: missing fields `gas_price` and `tx_type` in initializer of `eth::EthereumTransaction`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:153:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m153\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let eth_tx = EthereumTransaction {\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmissing `gas_price` and `tx_type`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `raw_tx` on type `SignedEthereumTransaction`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":5005,"byte_end":5011,"line_start":168,"line_end":168,"column_start":28,"column_end":34,"is_primary":true,"text":[{"text":"            raw_tx: signed.raw_tx,","highlight_start":28,"highlight_end":34}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a field with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/evm.rs","byte_start":5005,"byte_end":5011,"line_start":168,"line_end":168,"column_start":28,"column_end":34,"is_primary":true,"text":[{"text":"            raw_tx: signed.raw_tx,","highlight_start":28,"highlight_end":34}],"label":null,"suggested_replacement":"raw_hex","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `raw_tx` on type `SignedEthereumTransaction`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:168:28\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m168\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             raw_tx: signed.raw_tx,\n    \u001b[1m\u001b[94m|\u001b[0m                            \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a field with a similar name exists\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m168\u001b[0m \u001b[91m- \u001b[0m            raw_tx: signed.\u001b[91mraw_tx\u001b[0m,\n\u001b[1m\u001b[94m168\u001b[0m \u001b[92m+ \u001b[0m            raw_tx: signed.\u001b[92mraw_hex\u001b[0m,\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `tx_hash` on type `SignedEthereumTransaction`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":5041,"byte_end":5048,"line_start":169,"line_end":169,"column_start":29,"column_end":36,"is_primary":true,"text":[{"text":"            tx_hash: signed.tx_hash,","highlight_start":29,"highlight_end":36}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `raw_hex`, `hash`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `tx_hash` on type `SignedEthereumTransaction`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:169:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m169\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             tx_hash: signed.tx_hash,\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `raw_hex`, `hash`\n\n"}
{"$message_type":"diagnostic","message":"no field `from` on type `SignedEthereumTransaction`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":5075,"byte_end":5079,"line_start":170,"line_end":170,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"            from: signed.from,","highlight_start":26,"highlight_end":30}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `raw_hex`, `hash`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `from` on type `SignedEthereumTransaction`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:170:26\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m170\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             from: signed.from,\n    \u001b[1m\u001b[94m|\u001b[0m                          \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `raw_hex`, `hash`\n\n"}
{"$message_type":"diagnostic","message":"no method named `fingerprint` found for struct `eth::EthereumWallet` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/evm.rs","byte_start":5264,"byte_end":5275,"line_start":178,"line_end":178,"column_start":20,"column_end":31,"is_primary":true,"text":[{"text":"        self.inner.fingerprint()","highlight_start":20,"highlight_end":31}],"label":"method not found in `eth::EthereumWallet`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/eth.rs","byte_start":7731,"byte_end":7756,"line_start":258,"line_end":258,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"pub struct EthereumWallet {","highlight_start":1,"highlight_end":26}],"label":"method `fingerprint` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `fingerprint` found for struct `eth::EthereumWallet` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/evm.rs:178:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m178\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         self.inner.fingerprint()\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `eth::EthereumWallet`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/eth.rs:258:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m258\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct EthereumWallet {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-------------------------\u001b[0m \u001b[1m\u001b[94mmethod `fingerprint` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `InvalidNetwork` found for enum `WalletError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/sol.rs","byte_start":1262,"byte_end":1276,"line_start":45,"line_end":45,"column_start":37,"column_end":51,"is_primary":true,"text":[{"text":"            return Err(WalletError::InvalidNetwork(format!(","highlight_start":37,"highlight_end":51}],"label":"variant or associated item not found in `WalletError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/error.rs","byte_start":191,"byte_end":211,"line_start":10,"line_end":10,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub enum WalletError {","highlight_start":1,"highlight_end":21}],"label":"variant or associated item `InvalidNetwork` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no variant or associated item named `InvalidNetwork` found for enum `WalletError` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/sol.rs:45:37\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             return Err(WalletError::InvalidNetwork(format!(\n   \u001b[1m\u001b[94m|\u001b[0m                                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `WalletError`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/error.rs:10:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum WalletError {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m--------------------\u001b[0m \u001b[1m\u001b[94mvariant or associated item `InvalidNetwork` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `derive_path` found for struct `hd::ExtendedPrivateKey` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/hd.rs","byte_start":2416,"byte_end":2445,"line_start":81,"line_end":81,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"pub struct ExtendedPrivateKey {","highlight_start":1,"highlight_end":30}],"label":"method `derive_path` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/sol.rs","byte_start":2131,"byte_end":2142,"line_start":72,"line_end":72,"column_start":39,"column_end":50,"is_primary":true,"text":[{"text":"        let derived = self.master_key.derive_path(&DerivationPath::from_string(&path)?)?;","highlight_start":39,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `derive` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/sol.rs","byte_start":2131,"byte_end":2142,"line_start":72,"line_end":72,"column_start":39,"column_end":50,"is_primary":true,"text":[{"text":"        let derived = self.master_key.derive_path(&DerivationPath::from_string(&path)?)?;","highlight_start":39,"highlight_end":50}],"label":null,"suggested_replacement":"derive","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `derive_path` found for struct `hd::ExtendedPrivateKey` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/sol.rs:72:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let derived = self.master_key.derive_path(&DerivationPath::from_string(&path)?)?;\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/hd.rs:81:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtendedPrivateKey {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-----------------------------\u001b[0m \u001b[1m\u001b[94mmethod `derive_path` not found for this struct\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `derive` with a similar name\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[91m- \u001b[0m        let derived = self.master_key.\u001b[91mderive_path\u001b[0m(&DerivationPath::from_string(&path)?)?;\n\u001b[1m\u001b[94m72\u001b[0m \u001b[92m+ \u001b[0m        let derived = self.master_key.\u001b[92mderive\u001b[0m(&DerivationPath::from_string(&path)?)?;\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `from_string` found for struct `hd::DerivationPath` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/sol.rs","byte_start":2160,"byte_end":2171,"line_start":72,"line_end":72,"column_start":68,"column_end":79,"is_primary":true,"text":[{"text":"        let derived = self.master_key.derive_path(&DerivationPath::from_string(&path)?)?;","highlight_start":68,"highlight_end":79}],"label":"function or associated item not found in `hd::DerivationPath`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/hd.rs","byte_start":665,"byte_end":690,"line_start":25,"line_end":25,"column_start":1,"column_end":26,"is_primary":false,"text":[{"text":"pub struct DerivationPath {","highlight_start":1,"highlight_end":26}],"label":"function or associated item `from_string` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `hd::DerivationPath` consider using one of the following associated functions:\nhd::DerivationPath::from_str\nhd::DerivationPath::bitcoin_native_segwit\nhd::DerivationPath::bitcoin_legacy\nhd::DerivationPath::bitcoin_segwit_compat\nhd::DerivationPath::ethereum","code":null,"level":"note","spans":[{"file_name":"src/hd.rs","byte_start":805,"byte_end":848,"line_start":31,"line_end":31,"column_start":5,"column_end":48,"is_primary":true,"text":[{"text":"    pub fn from_str(path: &str) -> Result<Self> {","highlight_start":5,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/hd.rs","byte_start":1076,"byte_end":1152,"line_start":38,"line_end":38,"column_start":5,"column_end":81,"is_primary":true,"text":[{"text":"    pub fn bitcoin_native_segwit(account: u32, change: bool, index: u32) -> Self {","highlight_start":5,"highlight_end":81}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/hd.rs","byte_start":1376,"byte_end":1445,"line_start":46,"line_end":46,"column_start":5,"column_end":74,"is_primary":true,"text":[{"text":"    pub fn bitcoin_legacy(account: u32, change: bool, index: u32) -> Self {","highlight_start":5,"highlight_end":74}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/hd.rs","byte_start":1680,"byte_end":1756,"line_start":54,"line_end":54,"column_start":5,"column_end":81,"is_primary":true,"text":[{"text":"    pub fn bitcoin_segwit_compat(account: u32, change: bool, index: u32) -> Self {","highlight_start":5,"highlight_end":81}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/hd.rs","byte_start":1967,"byte_end":2016,"line_start":62,"line_end":62,"column_start":5,"column_end":54,"is_primary":true,"text":[{"text":"    pub fn ethereum(account: u32, index: u32) -> Self {","highlight_start":5,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is an associated function `from_str` with a similar name","code":null,"level":"help","spans":[{"file_name":"src/sol.rs","byte_start":2160,"byte_end":2171,"line_start":72,"line_end":72,"column_start":68,"column_end":79,"is_primary":true,"text":[{"text":"        let derived = self.master_key.derive_path(&DerivationPath::from_string(&path)?)?;","highlight_start":68,"highlight_end":79}],"label":null,"suggested_replacement":"from_str","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `from_string` found for struct `hd::DerivationPath` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/sol.rs:72:68\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let derived = self.master_key.derive_path(&DerivationPath::from_string(&path)?)?;\n   \u001b[1m\u001b[94m|\u001b[0m                                                                    \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `hd::DerivationPath`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/hd.rs:25:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct DerivationPath {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-------------------------\u001b[0m \u001b[1m\u001b[94mfunction or associated item `from_string` not found for this struct\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `hd::DerivationPath` consider using one of the following associated functions:\n      hd::DerivationPath::from_str\n      hd::DerivationPath::bitcoin_native_segwit\n      hd::DerivationPath::bitcoin_legacy\n      hd::DerivationPath::bitcoin_segwit_compat\n      hd::DerivationPath::ethereum\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hd.rs:31:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn from_str(path: &str) -> Result<Self> {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bitcoin_native_segwit(account: u32, change: bool, index: u32) -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bitcoin_legacy(account: u32, change: bool, index: u32) -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bitcoin_segwit_compat(account: u32, change: bool, index: u32) -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m62\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn ethereum(account: u32, index: u32) -> Self {\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an associated function `from_str` with a similar name\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m72\u001b[0m \u001b[91m- \u001b[0m        let derived = self.master_key.derive_path(&DerivationPath::\u001b[91mfrom_string\u001b[0m(&path)?)?;\n\u001b[1m\u001b[94m72\u001b[0m \u001b[92m+ \u001b[0m        let derived = self.master_key.derive_path(&DerivationPath::\u001b[92mfrom_str\u001b[0m(&path)?)?;\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `message` on type `&sol::SolanaTransaction`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/sol.rs","byte_start":4797,"byte_end":4804,"line_start":154,"line_end":154,"column_start":59,"column_end":66,"is_primary":true,"text":[{"text":"        let signature = sign_ed25519(&keypair.secret, &tx.message)?;","highlight_start":59,"highlight_end":66}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `to`, `lamports`, `recent_blockhash`, `memo`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `message` on type `&sol::SolanaTransaction`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/sol.rs:154:59\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m154\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let signature = sign_ed25519(&keypair.secret, &tx.message)?;\n    \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `to`, `lamports`, `recent_blockhash`, `memo`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/sol.rs","byte_start":5318,"byte_end":5356,"line_start":169,"line_end":169,"column_start":9,"column_end":47,"is_primary":true,"text":[{"text":"        sign_ed25519(&keypair.secret, message)","highlight_start":9,"highlight_end":47}],"label":"expected `Result<Vec<u8>, WalletError>`, found `Result<[u8; 64], WalletError>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/sol.rs","byte_start":5228,"byte_end":5243,"line_start":167,"line_end":167,"column_start":68,"column_end":83,"is_primary":false,"text":[{"text":"    pub fn sign_message(&self, message: &[u8], from_index: u32) -> Result<Vec<u8>> {","highlight_start":68,"highlight_end":83}],"label":"expected `std::result::Result<Vec<u8>, WalletError>` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `std::result::Result<Vec<u8>, _>`\n   found enum `std::result::Result<[u8; 64], _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/sol.rs:169:9\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m167\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn sign_message(&self, message: &[u8], from_index: u32) -> Result<Vec<u8>> {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                    \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mexpected `std::result::Result<Vec<u8>, WalletError>` because of return type\u001b[0m\n\u001b[1m\u001b[94m168\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let keypair = self.derive_ed25519_keypair(from_index)?;\n\u001b[1m\u001b[94m169\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         sign_ed25519(&keypair.secret, message)\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Result<Vec<u8>, WalletError>`, found `Result<[u8; 64], WalletError>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `std::result::Result<\u001b[1m\u001b[35mVec<u8>\u001b[0m, _>`\n               found enum `std::result::Result<\u001b[1m\u001b[35m[u8; 64]\u001b[0m, _>`\n\n"}
{"$message_type":"diagnostic","message":"`QrCode` doesn't implement `Debug`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/airgap.rs","byte_start":6179,"byte_end":6191,"line_start":196,"line_end":196,"column_start":5,"column_end":17,"is_primary":true,"text":[{"text":"    code: QrCode,","highlight_start":5,"highlight_end":17}],"label":"the trait `Debug` is not implemented for `QrCode`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/airgap.rs","byte_start":5933,"byte_end":5938,"line_start":187,"line_end":187,"column_start":10,"column_end":15,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone)]","highlight_start":10,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Debug)]","def_site_span":{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234/library/core/src/fmt/mod.rs","byte_start":34336,"byte_end":34351,"line_start":913,"line_end":913,"column_start":5,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: `QrCode` doesn't implement `Debug`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/airgap.rs:196:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m187\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m196\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     code: QrCode,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Debug` is not implemented for `QrCode`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Network: serde::Serialize` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/multichain.rs","byte_start":1923,"byte_end":1932,"line_start":68,"line_end":68,"column_start":24,"column_end":33,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize)]","highlight_start":24,"highlight_end":33}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/multichain.rs","byte_start":1923,"byte_end":1932,"line_start":68,"line_end":68,"column_start":24,"column_end":33,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize)]","highlight_start":24,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Serialize)]","def_site_span":{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_derive-1.0.228/src/lib.rs","byte_start":3101,"byte_end":3159,"line_start":114,"line_end":114,"column_start":1,"column_end":59,"is_primary":false,"text":[{"text":"pub fn derive_serialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":59}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/multichain.rs","byte_start":1978,"byte_end":1981,"line_start":70,"line_end":70,"column_start":5,"column_end":8,"is_primary":false,"text":[{"text":"    pub network: Network,","highlight_start":5,"highlight_end":8}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Serialize` is not implemented for `Network`","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1414,"byte_end":1430,"line_start":46,"line_end":46,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"pub enum Network {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for local types consider adding `#[derive(serde::Serialize)]` to your `Network` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Serialize`:\n  &'a T\n  &'a mut T\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\n  (T0, T1, T2, T3, T4)\nand 182 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `btc::_::_serde::ser::SerializeStruct::serialize_field`","code":null,"level":"note","spans":[{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/ser/mod.rs","byte_start":62575,"byte_end":62590,"line_start":1915,"line_end":1915,"column_start":8,"column_end":23,"is_primary":false,"text":[{"text":"    fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>","highlight_start":8,"highlight_end":23}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/ser/mod.rs","byte_start":62692,"byte_end":62701,"line_start":1917,"line_end":1917,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"        T: ?Sized + Serialize;","highlight_start":21,"highlight_end":30}],"label":"required by this bound in `SerializeStruct::serialize_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Network: serde::Serialize` is not satisfied\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/multichain.rs:68:24\n     \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m68\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize)]\n     \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n  \u001b[1m\u001b[94m69\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ChainBalance {\n  \u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub network: Network,\n     \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---\u001b[0m \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `Serialize` is not implemented for `Network`\n    \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:46:1\n     \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Network {\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for local types consider adding `#[derive(serde::Serialize)]` to your `Network` type\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Serialize`:\n               &'a T\n               &'a mut T\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n               (T0, T1, T2, T3)\n               (T0, T1, T2, T3, T4)\n             and 182 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `btc::_::_serde::ser::SerializeStruct::serialize_field`\n    \u001b[1m\u001b[94m--> \u001b[0m/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/ser/mod.rs:1917:21\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1915\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn serialize_field<T>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>\n     \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[94m1916\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     where\n\u001b[1m\u001b[94m1917\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         T: ?Sized + Serialize;\n     \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[92m^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `SerializeStruct::serialize_field`\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Serialize` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Network: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/multichain.rs","byte_start":1991,"byte_end":1998,"line_start":70,"line_end":70,"column_start":18,"column_end":25,"is_primary":true,"text":[{"text":"    pub network: Network,","highlight_start":18,"highlight_end":25}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Deserialize<'_>` is not implemented for `Network`","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1414,"byte_end":1430,"line_start":46,"line_end":46,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"pub enum Network {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `Network` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 194 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_element`","code":null,"level":"note","spans":[{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":63908,"byte_end":63920,"line_start":1769,"line_end":1769,"column_start":8,"column_end":20,"is_primary":false,"text":[{"text":"    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>","highlight_start":8,"highlight_end":20}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":63990,"byte_end":64006,"line_start":1771,"line_end":1771,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        T: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `SeqAccess::next_element`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Network: serde::Deserialize<'de>` is not satisfied\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/multichain.rs:70:18\n     \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub network: Network,\n     \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `Deserialize<'_>` is not implemented for `Network`\n    \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:46:1\n     \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Network {\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `Network` type\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n               &'a Path\n               &'a [u8]\n               &'a str\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n               (T0, T1, T2, T3)\n             and 194 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `next_element`\n    \u001b[1m\u001b[94m--> \u001b[0m/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs:1771:12\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1769\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>\n     \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[94m1770\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     where\n\u001b[1m\u001b[94m1771\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         T: Deserialize<'de>,\n     \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `SeqAccess::next_element`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Network: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/multichain.rs","byte_start":1991,"byte_end":1998,"line_start":70,"line_end":70,"column_start":18,"column_end":25,"is_primary":true,"text":[{"text":"    pub network: Network,","highlight_start":18,"highlight_end":25}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `Deserialize<'_>` is not implemented for `Network`","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1414,"byte_end":1430,"line_start":46,"line_end":46,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"pub enum Network {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `Network` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 194 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `next_value`","code":null,"level":"note","spans":[{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":68496,"byte_end":68506,"line_start":1914,"line_end":1914,"column_start":8,"column_end":18,"is_primary":false,"text":[{"text":"    fn next_value<V>(&mut self) -> Result<V, Self::Error>","highlight_start":8,"highlight_end":18}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs","byte_start":68568,"byte_end":68584,"line_start":1916,"line_end":1916,"column_start":12,"column_end":28,"is_primary":true,"text":[{"text":"        V: Deserialize<'de>,","highlight_start":12,"highlight_end":28}],"label":"required by this bound in `MapAccess::next_value`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Network: serde::Deserialize<'de>` is not satisfied\u001b[0m\n    \u001b[1m\u001b[94m--> \u001b[0msrc/multichain.rs:70:18\n     \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m70\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub network: Network,\n     \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `Deserialize<'_>` is not implemented for `Network`\n    \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:46:1\n     \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Network {\n     \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^\u001b[0m\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `Network` type\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n     \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n               &'a Path\n               &'a [u8]\n               &'a str\n               ()\n               (T,)\n               (T0, T1)\n               (T0, T1, T2)\n               (T0, T1, T2, T3)\n             and 194 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `next_value`\n    \u001b[1m\u001b[94m--> \u001b[0m/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_core-1.0.228/src/de/mod.rs:1916:12\n     \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m1914\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m----------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[94m1915\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     where\n\u001b[1m\u001b[94m1916\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         V: Deserialize<'de>,\n     \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `MapAccess::next_value`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Network: serde::Deserialize<'de>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/multichain.rs","byte_start":1934,"byte_end":1945,"line_start":68,"line_end":68,"column_start":35,"column_end":46,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize)]","highlight_start":35,"highlight_end":46}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/multichain.rs","byte_start":1934,"byte_end":1945,"line_start":68,"line_end":68,"column_start":35,"column_end":46,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, Serialize, Deserialize)]","highlight_start":35,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Deserialize)]","def_site_span":{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde_derive-1.0.228/src/lib.rs","byte_start":3397,"byte_end":3457,"line_start":122,"line_end":122,"column_start":1,"column_end":61,"is_primary":false,"text":[{"text":"pub fn derive_deserialize(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"the trait `Deserialize<'_>` is not implemented for `Network`","code":null,"level":"help","spans":[{"file_name":"src/lib.rs","byte_start":1414,"byte_end":1430,"line_start":46,"line_end":46,"column_start":1,"column_end":17,"is_primary":true,"text":[{"text":"pub enum Network {","highlight_start":1,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"for local types consider adding `#[derive(serde::Deserialize)]` to your `Network` type","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"for types from other crates check whether the crate offers a `serde` feature flag","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"the following other types implement trait `Deserialize<'de>`:\n  &'a Path\n  &'a [u8]\n  &'a str\n  ()\n  (T,)\n  (T0, T1)\n  (T0, T1, T2)\n  (T0, T1, T2, T3)\nand 194 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `btc::_::_serde::__private228::de::missing_field`","code":null,"level":"note","spans":[{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/src/private/de.rs","byte_start":837,"byte_end":850,"line_start":24,"line_end":24,"column_start":8,"column_end":21,"is_primary":false,"text":[{"text":"pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>","highlight_start":8,"highlight_end":21}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/src/private/de.rs","byte_start":912,"byte_end":928,"line_start":26,"line_end":26,"column_start":8,"column_end":24,"is_primary":true,"text":[{"text":"    V: Deserialize<'de>,","highlight_start":8,"highlight_end":24}],"label":"required by this bound in `missing_field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Network: serde::Deserialize<'de>` is not satisfied\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/multichain.rs:68:35\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m68\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, Serialize, Deserialize)]\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `Deserialize<'_>` is not implemented for `Network`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:46:1\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Network {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for local types consider adding `#[derive(serde::Deserialize)]` to your `Network` type\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: for types from other crates check whether the crate offers a `serde` feature flag\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Deserialize<'de>`:\n             &'a Path\n             &'a [u8]\n             &'a str\n             ()\n             (T,)\n             (T0, T1)\n             (T0, T1, T2)\n             (T0, T1, T2, T3)\n           and 194 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `btc::_::_serde::__private228::de::missing_field`\n  \u001b[1m\u001b[94m--> \u001b[0m/Users/jimxiao/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/serde-1.0.228/src/private/de.rs:26:8\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m-------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m25\u001b[0m \u001b[1m\u001b[94m|\u001b[0m where\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     V: Deserialize<'de>,\n   \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `missing_field`\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `Deserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"no method named `fingerprint` found for struct `hd::ExtendedPrivateKey` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/multichain.rs","byte_start":3134,"byte_end":3145,"line_start":103,"line_end":103,"column_start":38,"column_end":49,"is_primary":true,"text":[{"text":"        let fingerprint = btc_master.fingerprint();","highlight_start":38,"highlight_end":49}],"label":"method not found in `hd::ExtendedPrivateKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/hd.rs","byte_start":2416,"byte_end":2445,"line_start":81,"line_end":81,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"pub struct ExtendedPrivateKey {","highlight_start":1,"highlight_end":30}],"label":"method `fingerprint` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `fingerprint` found for struct `hd::ExtendedPrivateKey` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/multichain.rs:103:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m103\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let fingerprint = btc_master.fingerprint();\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `hd::ExtendedPrivateKey`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/hd.rs:81:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtendedPrivateKey {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-----------------------------\u001b[0m \u001b[1m\u001b[94mmethod `fingerprint` not found for this struct\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `clone` found for struct `hd::ExtendedPrivateKey` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/multichain.rs","byte_start":3294,"byte_end":3299,"line_start":107,"line_end":107,"column_start":50,"column_end":55,"is_primary":true,"text":[{"text":"        let eth = EthereumWallet::new(eth_master.clone(), Network::Ethereum)?;","highlight_start":50,"highlight_end":55}],"label":"method not found in `hd::ExtendedPrivateKey`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/hd.rs","byte_start":2416,"byte_end":2445,"line_start":81,"line_end":81,"column_start":1,"column_end":30,"is_primary":false,"text":[{"text":"pub struct ExtendedPrivateKey {","highlight_start":1,"highlight_end":30}],"label":"method `clone` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following trait defines an item `clone`, perhaps you need to implement it:\ncandidate #1: `Clone`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `clone` found for struct `hd::ExtendedPrivateKey` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/multichain.rs:107:50\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m107\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let eth = EthereumWallet::new(eth_master.clone(), Network::Ethereum)?;\n    \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `hd::ExtendedPrivateKey`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/hd.rs:81:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct ExtendedPrivateKey {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-----------------------------\u001b[0m \u001b[1m\u001b[94mmethod `clone` not found for this struct\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is implemented and in scope\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `InvalidNetwork` found for enum `WalletError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/multichain.rs","byte_start":6360,"byte_end":6374,"line_start":200,"line_end":200,"column_start":33,"column_end":47,"is_primary":true,"text":[{"text":"            .ok_or(WalletError::InvalidNetwork(format!(\"Chain ID {} not supported\", chain_id)))","highlight_start":33,"highlight_end":47}],"label":"variant or associated item not found in `WalletError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/error.rs","byte_start":191,"byte_end":211,"line_start":10,"line_end":10,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub enum WalletError {","highlight_start":1,"highlight_end":21}],"label":"variant or associated item `InvalidNetwork` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no variant or associated item named `InvalidNetwork` found for enum `WalletError` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/multichain.rs:200:33\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m200\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .ok_or(WalletError::InvalidNetwork(format!(\"Chain ID {} not supported\", chain_id)))\n    \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `WalletError`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/error.rs:10:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum WalletError {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m--------------------\u001b[0m \u001b[1m\u001b[94mvariant or associated item `InvalidNetwork` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `InvalidNetwork` found for enum `WalletError` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/multichain.rs","byte_start":6626,"byte_end":6640,"line_start":207,"line_end":207,"column_start":33,"column_end":47,"is_primary":true,"text":[{"text":"            .ok_or(WalletError::InvalidNetwork(format!(\"Chain ID {} not supported\", chain_id)))","highlight_start":33,"highlight_end":47}],"label":"variant or associated item not found in `WalletError`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/error.rs","byte_start":191,"byte_end":211,"line_start":10,"line_end":10,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub enum WalletError {","highlight_start":1,"highlight_end":21}],"label":"variant or associated item `InvalidNetwork` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no variant or associated item named `InvalidNetwork` found for enum `WalletError` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/multichain.rs:207:33\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m207\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .ok_or(WalletError::InvalidNetwork(format!(\"Chain ID {} not supported\", chain_id)))\n    \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `WalletError`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/error.rs:10:1\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum WalletError {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m--------------------\u001b[0m \u001b[1m\u001b[94mvariant or associated item `InvalidNetwork` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `get_all_addresses` found for reference `&btc::BitcoinWallet` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/multichain.rs","byte_start":8825,"byte_end":8842,"line_start":273,"line_end":273,"column_start":29,"column_end":46,"is_primary":true,"text":[{"text":"            for addr in btc.get_all_addresses() {","highlight_start":29,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `get_address` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"src/btc.rs","byte_start":6443,"byte_end":6523,"line_start":218,"line_end":218,"column_start":5,"column_end":85,"is_primary":true,"text":[{"text":"    pub fn get_address(&self, is_change: bool, index: u32) -> Result<BitcoinAddress> {","highlight_start":5,"highlight_end":85}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `get_all_addresses` found for reference `&btc::BitcoinWallet` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/multichain.rs:273:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m273\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for addr in btc.get_all_addresses() {\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `get_address` with a similar name, but with different arguments\n   \u001b[1m\u001b[94m--> \u001b[0msrc/btc.rs:218:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m218\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn get_address(&self, is_change: bool, index: u32) -> Result<BitcoinAddress> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/multichain.rs","byte_start":8878,"byte_end":8882,"line_start":274,"line_end":274,"column_start":32,"column_end":36,"is_primary":true,"text":[{"text":"                addresses.push(addr.into());","highlight_start":32,"highlight_end":36}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/multichain.rs:274:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m274\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 addresses.push(addr.into());\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `get_all_addresses` found for reference `&eth::EthereumWallet` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/multichain.rs","byte_start":9009,"byte_end":9026,"line_start":280,"line_end":280,"column_start":29,"column_end":46,"is_primary":true,"text":[{"text":"            for addr in eth.get_all_addresses() {","highlight_start":29,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `get_address` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"src/eth.rs","byte_start":8620,"byte_end":8684,"line_start":289,"line_end":289,"column_start":5,"column_end":69,"is_primary":true,"text":[{"text":"    pub fn get_address(&self, index: u32) -> Result<EthereumAddress> {","highlight_start":5,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `get_all_addresses` found for reference `&eth::EthereumWallet` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/multichain.rs:280:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m280\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             for addr in eth.get_all_addresses() {\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `get_address` with a similar name, but with different arguments\n   \u001b[1m\u001b[94m--> \u001b[0msrc/eth.rs:289:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m289\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn get_address(&self, index: u32) -> Result<EthereumAddress> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/multichain.rs","byte_start":9062,"byte_end":9066,"line_start":281,"line_end":281,"column_start":32,"column_end":36,"is_primary":true,"text":[{"text":"                addresses.push(addr.into());","highlight_start":32,"highlight_end":36}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/multichain.rs:281:32\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m281\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 addresses.push(addr.into());\n    \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"non-exhaustive patterns: `Network::EthereumSepolia`, `Network::Polygon`, `Network::PolygonMumbai` and 8 more not covered","code":{"code":"E0004","explanation":"This error indicates that the compiler cannot guarantee a matching pattern for\none or more possible inputs to a match expression. Guaranteed matches are\nrequired in order to assign values to match expressions, or alternatively,\ndetermine the flow of execution.\n\nErroneous code example:\n\n```compile_fail,E0004\nenum Terminator {\n    HastaLaVistaBaby,\n    TalkToMyHand,\n}\n\nlet x = Terminator::HastaLaVistaBaby;\n\nmatch x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n    Terminator::TalkToMyHand => {}\n}\n```\n\nIf you encounter this error you must alter your patterns so that every possible\nvalue of the input type is matched. For types with a small number of variants\n(like enums) you should probably cover all cases explicitly. Alternatively, the\nunderscore `_` wildcard pattern can be added after all other patterns to match\n\"anything else\". Example:\n\n```\nenum Terminator {\n    HastaLaVistaBaby,\n    TalkToMyHand,\n}\n\nlet x = Terminator::HastaLaVistaBaby;\n\nmatch x {\n    Terminator::TalkToMyHand => {}\n    Terminator::HastaLaVistaBaby => {}\n}\n\n// or:\n\nmatch x {\n    Terminator::TalkToMyHand => {}\n    _ => {}\n}\n```\n"},"level":"error","spans":[{"file_name":"src/hd.rs","byte_start":2677,"byte_end":2684,"line_start":90,"line_end":90,"column_start":34,"column_end":41,"is_primary":true,"text":[{"text":"        let network_kind = match network {","highlight_start":34,"highlight_end":41}],"label":"patterns `Network::EthereumSepolia`, `Network::Polygon`, `Network::PolygonMumbai` and 8 more not covered","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Network` defined here","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":1423,"byte_end":1430,"line_start":46,"line_end":46,"column_start":10,"column_end":17,"is_primary":true,"text":[{"text":"pub enum Network {","highlight_start":10,"highlight_end":17}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1538,"byte_end":1553,"line_start":53,"line_end":53,"column_start":5,"column_end":20,"is_primary":false,"text":[{"text":"    EthereumSepolia,","highlight_start":5,"highlight_end":20}],"label":"not covered","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1574,"byte_end":1581,"line_start":55,"line_end":55,"column_start":5,"column_end":12,"is_primary":false,"text":[{"text":"    Polygon,","highlight_start":5,"highlight_end":12}],"label":"not covered","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1587,"byte_end":1600,"line_start":56,"line_end":56,"column_start":5,"column_end":18,"is_primary":false,"text":[{"text":"    PolygonMumbai,","highlight_start":5,"highlight_end":18}],"label":"not covered","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1606,"byte_end":1614,"line_start":57,"line_end":57,"column_start":5,"column_end":13,"is_primary":false,"text":[{"text":"    Arbitrum,","highlight_start":5,"highlight_end":13}],"label":"not covered","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib.rs","byte_start":1620,"byte_end":1634,"line_start":58,"line_end":58,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    ArbitrumGoerli,","highlight_start":5,"highlight_end":19}],"label":"not covered","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"the matched value is of type `Network`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms","code":null,"level":"help","spans":[{"file_name":"src/hd.rs","byte_start":2840,"byte_end":2840,"line_start":92,"line_end":92,"column_start":83,"column_end":83,"is_primary":true,"text":[{"text":"            Network::BitcoinTestnet | Network::EthereumGoerli => NetworkKind::Test,","highlight_start":83,"highlight_end":83}],"label":null,"suggested_replacement":",\n            _ => todo!()","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0004]\u001b[0m\u001b[1m: non-exhaustive patterns: `Network::EthereumSepolia`, `Network::Polygon`, `Network::PolygonMumbai` and 8 more not covered\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/hd.rs:90:34\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m90\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let network_kind = match network {\n   \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mpatterns `Network::EthereumSepolia`, `Network::Polygon`, `Network::PolygonMumbai` and 8 more not covered\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: `Network` defined here\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:46:10\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Network {\n   \u001b[1m\u001b[94m|\u001b[0m          \u001b[1m\u001b[92m^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     EthereumSepolia,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m---------------\u001b[0m \u001b[1m\u001b[94mnot covered\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     // EVM L2s\n\u001b[1m\u001b[94m55\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Polygon,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------\u001b[0m \u001b[1m\u001b[94mnot covered\u001b[0m\n\u001b[1m\u001b[94m56\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     PolygonMumbai,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-------------\u001b[0m \u001b[1m\u001b[94mnot covered\u001b[0m\n\u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Arbitrum,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mnot covered\u001b[0m\n\u001b[1m\u001b[94m58\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     ArbitrumGoerli,\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mnot covered\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the matched value is of type `Network`\n\u001b[1m\u001b[96mhelp\u001b[0m: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown, or multiple match arms\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m92\u001b[0m \u001b[92m~ \u001b[0m            Network::BitcoinTestnet | Network::EthereumGoerli => NetworkKind::Test\u001b[92m,\u001b[0m\n\u001b[1m\u001b[94m93\u001b[0m \u001b[92m~             _ => todo!()\u001b[0m,\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `e`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/btc.rs","byte_start":2004,"byte_end":2005,"line_start":66,"line_end":66,"column_start":23,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| WalletError::InvalidPublicKey)?;","highlight_start":23,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/btc.rs","byte_start":2004,"byte_end":2005,"line_start":66,"line_end":66,"column_start":23,"column_end":24,"is_primary":true,"text":[{"text":"            .map_err(|e| WalletError::InvalidPublicKey)?;","highlight_start":23,"highlight_end":24}],"label":null,"suggested_replacement":"_e","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `e`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/btc.rs:66:23\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m66\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .map_err(|e| WalletError::InvalidPublicKey)?;\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[33m^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_e`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `network`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/btc.rs","byte_start":2439,"byte_end":2446,"line_start":81,"line_end":81,"column_start":33,"column_end":40,"is_primary":true,"text":[{"text":"    pub fn parse(address: &str, network: Network) -> Result<Address<bitcoin::address::NetworkUnchecked>> {","highlight_start":33,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/btc.rs","byte_start":2439,"byte_end":2446,"line_start":81,"line_end":81,"column_start":33,"column_end":40,"is_primary":true,"text":[{"text":"    pub fn parse(address: &str, network: Network) -> Result<Address<bitcoin::address::NetworkUnchecked>> {","highlight_start":33,"highlight_end":40}],"label":null,"suggested_replacement":"_network","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `network`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/btc.rs:81:33\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m81\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn parse(address: &str, network: Network) -> Result<Address<bitcoin::address::NetworkUnchecked>> {\n   \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[33m^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_network`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `i`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/eth.rs","byte_start":2976,"byte_end":2977,"line_start":96,"line_end":96,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"        for (i, (c, h)) in addr.chars().zip(hash_hex.chars()).enumerate() {","highlight_start":14,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/eth.rs","byte_start":2976,"byte_end":2977,"line_start":96,"line_end":96,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"        for (i, (c, h)) in addr.chars().zip(hash_hex.chars()).enumerate() {","highlight_start":14,"highlight_end":15}],"label":null,"suggested_replacement":"_i","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `i`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/eth.rs:96:14\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         for (i, (c, h)) in addr.chars().zip(hash_hex.chars()).enumerate() {\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[33m^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_i`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 37 previous errors; 13 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 37 previous errors; 13 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0004, E0063, E0277, E0282, E0308, E0599, E0609.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0004, E0063, E0277, E0282, E0308, E0599, E0609.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0004`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0004`.\u001b[0m\n"}
